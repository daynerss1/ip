package barry;

import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.Arrays;

import barry.exception.BarryException;
import barry.parser.ParsedInput;
import barry.parser.Parser;
import barry.storage.Storage;
import barry.task.Deadline;
import barry.task.Event;
import barry.task.Task;
import barry.task.TaskList;
import barry.task.ToDo;
import barry.ui.Ui;

/**
 * The main entry point and orchestrator for the Barry chatbot application.
 *
 * <p>Barry coordinates interactions between the {@code Ui} (user I/O), {@code Parser} (command parsing),
 * {@code TaskList} (in-memory task state), and {@code Storage} (persistence).
 * It runs the main input loop, executes user commands, and saves tasks whenever the list changes.</p>
 */
public class Barry {
    private static final String SAMPLE_TASK_BOOTSTRAP_MESSAGE =
            "First voyage detected. I loaded a few sample tasks to get you started.";
    private final Ui ui;
    private final TaskList userList;
    private final Storage storage;
    private String startupMessage = null;
    private boolean shouldUseShortWelcome = false;
    private boolean lastResponseWasError = false;

    /**
     * Creates a new Barry chatbot instance.
     * Initializes UI and storage components, then attempts to load
     * saved tasks from the given file path.
     * If loading fails (e.g., corrupted file),
     * Barry starts with an empty task list and reports the error to the user.
     *
     * @param filePath Relative path to the save file (e.g., "./data/barry.txt").
     */
    public Barry(String filePath) {
        assert filePath != null : "filePath must not be null";
        this.ui = new Ui();
        this.storage = new Storage(filePath);
        this.userList = loadTaskListFromStorage();
        assert ui != null : "ui must not be null";
        assert storage != null : "storage must not be null";
        assert userList != null : "userList must not be null";
    }

    private TaskList loadTaskListFromStorage() {
        boolean isFirstRun = !storage.dataFileExists();
        try {
            TaskList loadedTasks = new TaskList(storage.load());
            if (isFirstRun && loadedTasks.size() == 0) {
                seedSampleTasks(loadedTasks);
                shouldUseShortWelcome = true;
                startupMessage = ui.formatStartupInfo(
                        SAMPLE_TASK_BOOTSTRAP_MESSAGE,
                        "Type 'help' to view all navigation commands."
                );
            }
            return loadedTasks;
        } catch (BarryException e) {
            startupMessage = ui.formatLoadingError("Saved data was corrupted. Starting a new file. "
                    + e.getMessage()
            );
            return new TaskList();
        }
    }

    /**
     * Helps the FXML controller to print the welcome message.
     * @return The welcome message.
     */
    public String getWelcomeMessage() {
        if (shouldUseShortWelcome) {
            return ui.formatWelcomeShort();
        }
        return ui.formatWelcome();
    }

    /**
     * Helps the FMXL controller to print the load error message, if applicable.
     * @return the load error message, if any.
     */
    public String consumeStartupMessage() {
        String msg = startupMessage;
        startupMessage = null;
        return msg;
    }

    /**
     * Runs the main interaction loop of the chatbot.
     * Reads user commands from the UI, parses them using {@link barry.parser.Parser},
     * executes the corresponding operations on the task list,
     * and saves changes via {@link barry.storage.Storage}
     * when the task list is modified.
     */
    public String getResponse(String input) {
        try {
            ParsedInput parsedInput = Parser.parse(input);
            assert parsedInput != null : "parsed input must not be null";
            assert parsedInput.type != null : "parsed input type must not be null";
            String response = handleCommand(parsedInput);
            lastResponseWasError = false;
            return response;
        } catch (BarryException e) {
            lastResponseWasError = true;
            return ui.formatError(e.getMessage());
        }
    }

    /**
     * Returns whether the latest response generated by Barry was an error.
     *
     * @return true if the latest response is an error message, otherwise false.
     */
    public boolean wasLastResponseError() {
        return lastResponseWasError;
    }

    private String handleCommand(ParsedInput parsedInput) throws BarryException {
        switch (parsedInput.type) {
        case LIST:
            return handleList();
        case HELP:
            return handleHelp();
        case TODO:
            return handleToDo(parsedInput);
        case DEADLINE:
            return handleDeadline(parsedInput);
        case EVENT:
            return handleEvent(parsedInput);
        case MARK:
            return handleMark(parsedInput.taskNumbers);
        case UNMARK:
            return handleUnmark(parsedInput.taskNumbers);
        case DELETE:
            return handleDelete(parsedInput.taskNumbers);
        case FIND:
            return handleFind(parsedInput);
        case BYE:
            return handleBye();
        default:
            throw new BarryException("Unknown command");
        }
    }

    private String handleList() {
        return ui.formatTaskList(userList);
    }

    private String handleHelp() {
        return ui.formatHelp();
    }

    private String handleToDo(ParsedInput parsedInput) throws BarryException {
        Task task = new ToDo(parsedInput.name);
        return addTaskAndRespond(task);
    }

    private String handleDeadline(ParsedInput parsedInput) throws BarryException {
        Task task = new Deadline(parsedInput.name, parsedInput.by);
        return addTaskAndRespond(task);
    }

    private String handleEvent(ParsedInput parsedInput) throws BarryException {
        Task task = new Event(parsedInput.name, parsedInput.start, parsedInput.end);
        return addTaskAndRespond(task);
    }

    private String handleMark(int... nums) throws BarryException {
        validateTaskNumbers(nums);
        ArrayList<Task> markedTasks = markTasks(nums);
        saveTasks();
        return ui.formatTaskMarked(markedTasks);
    }

    private String handleUnmark(int... nums) throws BarryException {
        validateTaskNumbers(nums);
        ArrayList<Task> unmarkedTasks = unmarkTasks(nums);
        saveTasks();
        return ui.formatTaskUnmarked(unmarkedTasks);
    }

    private String handleDelete(int... nums) throws BarryException {
        validateTaskNumbers(nums);
        int[] sortedNums = sortTaskNumbers(nums);
        ArrayList<Task> tasksToDelete = collectTasksForDeletion(nums);
        int initialSize = userList.size();
        deleteTasksInReverse(sortedNums);
        saveTasks();
        int updatedSize = initialSize - tasksToDelete.size();
        return ui.formatTaskDeleted(updatedSize, tasksToDelete);
    }

    private String handleFind(ParsedInput parsedInput) {
        return ui.formatFindResults(userList.findByKeyword(parsedInput.name));
    }

    private String handleBye() {
        return ui.formatBye();
    }

    private String addTaskAndRespond(Task task) throws BarryException {
        userList.addTask(task);
        saveTasks();
        return ui.formatTaskAdded(task, userList.size());
    }

    private void saveTasks() throws BarryException {
        storage.save(userList);
    }

    private void seedSampleTasks(TaskList tasks) throws BarryException {
        assert tasks != null : "tasks must not be null";
        tasks.addTask(new ToDo("Learn the controls with 'help'"));
        tasks.addTask(new Deadline("Submit your first real task", LocalDateTime.of(2026, 12, 31, 18, 0)));
        tasks.addTask(new Event("Plot your week", LocalDateTime.of(2026, 12, 20, 9, 0),
                LocalDateTime.of(2026, 12, 20, 10, 0)));
        storage.save(tasks);
    }

    private void validateTaskNumbers(int[] nums) throws BarryException {
        assert nums != null : "task numbers must not be null";
        for (int n : nums) {
            assert n > 0 : "task numbers must be positive";
            userList.ensureIndexInRange1Based(n);
        }
    }

    private Task getTaskByNumber(int number) {
        return userList.getTask(number - 1);
    }

    private ArrayList<Task> markTasks(int... nums) {
        ArrayList<Task> marked = new ArrayList<>();
        for (int n : nums) {
            Task task = getTaskByNumber(n);
            task.mark();
            marked.add(task);
        }
        return marked;
    }

    private ArrayList<Task> unmarkTasks(int... nums) {
        ArrayList<Task> unmarked = new ArrayList<>();
        for (int n : nums) {
            Task task = getTaskByNumber(n);
            task.unmark();
            unmarked.add(task);
        }
        return unmarked;
    }

    private int[] sortTaskNumbers(int... nums) {
        int[] copy = Arrays.copyOf(nums, nums.length);
        Arrays.sort(copy);
        return copy;
    }

    private ArrayList<Task> collectTasksForDeletion(int... nums) {
        ArrayList<Task> tasksToDelete = new ArrayList<>();
        for (int n : nums) {
            tasksToDelete.add(getTaskByNumber(n));
        }
        return tasksToDelete;
    }

    private void deleteTasksInReverse(int... sortedNums) {
        for (int i = sortedNums.length - 1; i >= 0; i--) {
            int n = sortedNums[i];
            userList.removeTask(n - 1);
        }
    }
}
